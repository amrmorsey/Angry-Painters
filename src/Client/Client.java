/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package Client;
import Server.Server;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
/**
 *
 * @author Amr Hisham Said Morsey, ID:900 133 274
 * this class creates a client.
 */
public class Client extends javax.swing.JFrame implements Runnable {
    static boolean myTurn = false; // tells the user if its his turn or not
    static boolean isWin = false; // false if he did not win, true otherwise
    static int hit = 0; // count how many times his aim hit
    static ServerSocket ss;
    static Socket s; //socket to connect to server
    static PrintWriter out; // to send to server
    static BufferedReader in; // to recieve from server
    panel p = new panel(); // an instance of object panel
    /**
     * Creates new form Client
     */
    public Client() {
        super("Client");
        try {
            s = new Socket("localhost", 8080); // connects to server
            PrintWriter out = new PrintWriter(s.getOutputStream(), true); // establish output
            BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream())); // establish input
            
            initComponents();
            this.setSize(900, 563); // set window size
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            Thread t = new Thread(this);// creates thread of this class
            
            this.add(p); // adds the panel to the jframe
            this.addKeyListener(p); // adds a key listener
            this.setVisible(true);// make the winow visibile
            t.start();
        } catch (IOException ex) {
            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    /**
     * sends the move that has been made to the server
     * @param s string that describes the move.
     */
    public static void sendMove(String s){ 
        out.println(s);
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            /* Set the Nimbus look and feel */
            //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
            /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
            * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
            */
            try {
                for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                    if ("Nimbus".equals(info.getName())) {
                        javax.swing.UIManager.setLookAndFeel(info.getClassName());
                        break;
                    }
                }
            } catch (ClassNotFoundException ex) {
                java.util.logging.Logger.getLogger(Client.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            } catch (InstantiationException ex) {
                java.util.logging.Logger.getLogger(Client.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            } catch (IllegalAccessException ex) {
                java.util.logging.Logger.getLogger(Client.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            } catch (javax.swing.UnsupportedLookAndFeelException ex) {
                java.util.logging.Logger.getLogger(Client.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            }
            //</editor-fold>
            s = new Socket("localhost", 8080);
            PrintWriter out = new PrintWriter(s.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));
            
            /* Create and display the form */
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    new Client().setVisible(true);
                }
            });
        } catch (IOException ex) {
            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    boolean proj = true; // to create projectile-like motion
    /**
     * This method takes a string and tries to mimic the move that the
     * server did.
     * @param s string describing the move.
     */
    public void mimicMove(String s){
        if(s.equalsIgnoreCase("left")){
            p.sx = p.sx-10;
            p.psx = p.psx-10;
            p.repaint();
        }
        if(s.equalsIgnoreCase("right")){
            p.sx = p.sx+10;
            p.psx = p.psx+10;
            p.repaint();
        }
        if(s.equalsIgnoreCase("space")){
             if(proj){
                p.psx -= 10;
                p.psy -=10;
            }
            else{
                p.psx -=10;
                p.psy +=10;
            }
            if(p.psy<200)
                proj = false;

            repaint();
        }
        if(s.equalsIgnoreCase("hit")){
                    JOptionPane.showMessageDialog(this, "HIT");
                    myTurn = true;
                    p.paintx = p.x +20;
                    p.painty = p.y+20;
                    proj = true;
                    p.psx = p.sx+20;
                    p.psy = p.sy+20;
        }
        if(s.equalsIgnoreCase("Finished")){
                    myTurn = true;
                    p.paintx = p.x +20;
                    p.painty = p.y+20;
                    proj = true;
                    p.psx = p.sx+20;
                    p.psy = p.sy+20;
                }
         if(s.equalsIgnoreCase("win"))
            {
                JOptionPane.showMessageDialog(this,"You lose");
                this.setVisible(false);
                this.dispose();
            }
    }
    @Override
    public void run() {
        while(true){ // works for ever until game finishes
            try {
                String serverMove;
                out = new PrintWriter(s.getOutputStream(), true); 
                in = new BufferedReader(new InputStreamReader(s.getInputStream()));
                
                serverMove = in.readLine(); // gets the move that the server did.
                System.out.println(serverMove);
                mimicMove(serverMove); // tries to apply the same move here.

                if(isWin){ // check if the client wins
                    this.setVisible(false);
                    this.dispose();
                }
            } catch (IOException ex) {
                Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}
/**
 * class panel that extends JPanel is the class that have all the images
 * and applies all the moves.
 * @author Amr Hisham Said
 */
class panel extends javax.swing.JPanel implements MouseListener, KeyListener{

    /**
     * Creates new form panel
     */
    Toolkit t = Toolkit.getDefaultToolkit(); 
    Image bg = t.getImage("bg.png");//background image
    Image red = t.getImage("red.png");//red house
    int x =100;
    int y = 470;
    int paintx =x+20;
    int painty =y+20;
    Image blue = t.getImage("blue.png"); // blue house
    Image rp = t.getImage("rb.png"); // red painter
    Image bp = t.getImage("rp.png"); // blue painter
    Image r = t.getImage("r.png"); // red paint
    Image b = t.getImage("b.png"); // blue paint
    int sx = 800;
    int sy = 470;
    int psx = 800+20;
    int psy = 470+20;
    public panel() {
        super(true);
        this.setSize(900, 563);
        this.setOpaque(false);
        initComponents();
    }
    /**
     * draws all the images into the panel.
     * @param g 
     */
    @Override
    public void paintComponent(Graphics g){
        g.drawImage(bg, 0, 0, this);
        g.drawImage(red, 800, 400, this);
        g.drawImage(blue, 0, 400, this);
        g.drawImage(bp, x, y, this);
        g.drawImage(b,paintx,painty,this);
        g.drawImage(rp, sx, sy, this);
        g.drawImage(r,psx,psy,this);
        
    }
    /**
     * to create a projectile like motion.
     */
    boolean flag = true;
    void projectile(){

        
        

            if(flag){
                paintx += 10;
                painty -=10;
            }
            else{
                paintx +=10;
                painty +=10;
            }
            if(painty<200)
                flag = false;

            repaint();

        
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>                        


    // Variables declaration - do not modify                     
    // End of variables declaration                   

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println("panel");
        repaint();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mousePressed(MouseEvent e) {
        repaint();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseExited(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyTyped(KeyEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
    boolean onlySpace = false;
    @Override
    /**
     * responsible for the actions that comes from the keys. moving the images.
     * 
     */
    public void keyPressed(KeyEvent e) {
        int keycode = e.getKeyCode();
        //System.out.println(keycode);
        if(Client.myTurn){
        switch(keycode){
            case KeyEvent.VK_LEFT: if(!onlySpace){paintx = paintx-10;x = x -10;Client.sendMove("Left");}break;
            case KeyEvent.VK_RIGHT:if(!onlySpace){paintx = paintx+10;x = x +10 ;Client.sendMove("Right");}break;
            case KeyEvent.VK_SPACE:
                if(isHit()){
                    if(isWin()){
                    JOptionPane.showMessageDialog(this, "YOU WIN");
                    Client.sendMove("win");
                     }else{
                                    JOptionPane.showMessageDialog(this, "HIT");
                                    flag=true;onlySpace=false;
                                    Client.myTurn = false;
                                    Client.sendMove("Hit");}
                              }else{
                                    if(painty>500){
                                        Client.myTurn = false;
                                        flag=true;onlySpace=false;
                                        Client.sendMove("Finished");}
                                    else{
                                        projectile();
                                        onlySpace=true;
                                        Client.sendMove("Space");}
            }
            break;
        }
        //System.out.println(x+boat.getWidth(this)/2+" "+y);
        repaint();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }
    }
    /**
     * check if player his the other house
     * @return true if the player hit, false other wise.
     */
    boolean isHit(){
        if(paintx>800&&painty>400)
        {
            Client.hit++;
           return true; 
        }
            
        return false;
    }
    /**
     * checks if player won.
     * @return true if won, false otherwise.
     */
    boolean isWin(){
        if(Client.hit ==4){
            Client.isWin = true;
             return true;
        }
           
        return false;
    }
    @Override
    public void keyReleased(KeyEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}